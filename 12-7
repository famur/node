1.下面的程序执行输出几个hello？
#include<stdio.h>
#include <unistd.h>
int main( ) {
fork( );
fork( );
fork( );
printf(“hello\n”);
return 0;
}

fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。
fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次.
fork(); //2个进程
fork(); //4个进程
fork(); //8个进程

通常所说的"存储保护"的基本含义是（）。
  防止程序间相互越界访问
下列进程调度算法中，（）可能会出现进程长期得不到调度的情况。
  强占式静态优先权法
cache 缓存适用的场景
B 使用了多线程机制的服务
C 单条线程尺寸太小的数据
D 有着大量访问的服务

虚拟存储只能基于非连续分配技术

能在用户态发生的事件
A 系统调用
B 外部中断
D 缺页

在使用锁保证线程安全时，可能会出现活跃度失败的情况，活跃度失败主要包括
A 死锁
B 饥饿
C 活锁
进程死锁原因
1) 系统资源的竞争通常系统中拥有的不可剥夺资源，其数量不足以满足多个进程运行的需要，使得进程在 运行过程中，会因争夺资源而陷入僵局，如磁带机、打印机等。只有对不可剥夺资源的竞争 才可能产生死锁，对可剥夺资源的竞争是不会引起死锁的。
2) 进程推进顺序非法进程在运行过程中，请求和释放资源的顺序不当，也同样会导致死锁。例如，并发进程 P1、P2分别保持了资源R1、R2，而进程P1申请资源R2，进程P2申请资源R1时，两者都 会因为所需资源被占用而阻塞。
3）信号量使用不当也会造成死锁。进程间彼此相互等待对方发来的消息，结果也会使得这 些进程间无法继续向前推进。例如，进程A等待进程B发的消息，进程B又在等待进程A 发的消息，可以看出进程A和B不是因为竞争同一资源，而是在等待对方的资源导致死锁。
