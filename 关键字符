1.关键字：extern  来对变量作“外部变量声明”，以扩展全局变量的作用域。也就是说，如果在变量定义之前要使用该变量，
则应在使用之前加 extern 声明变量，使作用域扩展到从声明开始到本文件结束。在c++中用c的函数。

定义与声明：定义创建了对象并为这个对象分配内存，声明并没有。

register 请求编译器尽可能的将变量存在cpu内部寄存器中而不是通过内存寻址访问以提高效率。修饰限制变量必须是能被CPU寄存器所接受的
类型，意味着register变量必须是一个单个的值，并且其长度应小于或等于整型的长度。而且register变量可能不存放在内存中，
所以不能用取地址运算符“&”来获取register变量的地址。

static  静态全局变量，作用域仅限于变量被定义的文件中，其他文件即使使用extern声明也没有使用权力，作用域是从定义之处开始，
到文件结尾之处，在定义之处前面的那些代码行也不能使用它，使用就得加extern。
          静态局部变量在函数体里定义的，就只能在这个函数里用。
sizeof  int a[100];   sizeof(a) 400   sizeof(a[100]) 4  sizeof(&a)  4    sizeof(&a[0])  4
		sizeof表示的是变量占用字的节数。

a本身是个地址，用int存放，占用4个字节。
int就是4，a[100]一共是100个int变量，就是400.
a[100] 第100元素的占用字节数 4
&a也是个地址值（存放a的地址的空间内存的地址），一个地址用int存放也是4
&a[0]  a[0]这个数的地址大小，占用4

char 类型的范围为[-128,127]
	int main()
{
	char a[1000];
	int i;
	for (i = 0; i < 1000; i++)
	{
		a[i] = -1 - i;

	}

	printf("%d", strlen(a));
	system("pause");
	return 0;
}
-0和+0在内存中存储		对于数值表示支持三种表示法，分别是符号数值表示法、反码表示法和补码表示法。补码表示法没有负0，
反码和符号数值表示法存在负0，它们的负0的MSB都是1，其余位为0。

隐式转换规则如下：
1. 程式在执行算术运算时，低类型能够转换为高类型。
2. 在赋值表达式中，右边表达式的值自动隐式转换为左边变量的类型，并赋值给他。
3. 当在函数调用时，将实参值赋给形参，系统隐式地将实参转换为形参的类型后，赋给形参。
4. 函数有返回值时，系统将自动地将返回表达式类型转换为函数类型后，赋值给调用函数。

case 后面只能是整型或字符型常量表达式。 default 不要省略。
goto 可以灵活跳转，可能跳过了变量初始化，重要的计算语句。
void  对函数返回的限定；对函数参数的限定。按照ANSI标准，不能对void指针进行算法操作
       void *pvoid;
        pvoid++;       pvoid +=1;   都是错误的操作
进行算法操作的指针必须是确定知道其指向数据类型的大小的。也就是说必须知道内存目的地址的确切值。不能代表一个真实的变量。

const  修饰只读变量，其值在编译时不能被使用，因为编译器在编译时不知道其储存的内容。节省空间，避免不必要的内存分配，同时提高效率。
（不为const修饰的只读变量分配存储空间，而是将它们保存在符号表中）

volatile  编译器对访问该变量的代码不在优化，从而可以提供对特殊地址的稳定访问

在C语言中，修饰符extern用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”。

struct  柔性数组 ：结构中的最后一个元素允许是未知大小的数组，这就叫做柔性数组成员，但结构中的柔性数组成员前面必须至少一个其他成员
 。柔性数组成员允许结构中包含一个大小可以变的数组。sizeof返回的这种结构大小不包括柔性数组的内存。包含柔性数组的成员的结构用malloc（）
函数进行内存大小的动态分配，并且分配的大小应该大于结构体的大小，以适应柔性数组的预期大小。
	typedef struct st_type
	{
		int i;
		int a[];
	}type_a;

union 在union中所有数据成员共用一个空间，同一时间只能储存其中一个数据成员，所有的数据成员具有相同的起始地址。
在c++中于struct 相同为public

enum 枚举类型
下面再看看枚举与#define 宏的区别：
1），#define 宏常量是在预编译阶段进行简单替换。枚举常量则是在编译的时候确定其值。
2），一般在编译器里，可以调试枚举常量，但是不能调试宏常量。
3），枚举可以一次定义大量相关的常量，而#define 宏一次只能定义一个。
留两个问题：
A），枚举能做到事，#define 宏能不能都做到？如果能，那为什么还需要枚举？ B)，sizeof（ColorVal）的值为多少？为什么？

（1）一方面枚举可以集中管理数据，具有相同属性的整形数据可以使用枚举存放；另外枚举可以实现“取值的自增”（当然也可以指定每个枚举的值）
，编写代码更容易，减少出错的机会，后续维护时如果需要新增一个信息无需计算该信息取值。
（2)这个变量类型不清楚，因此其取值取决于其原始类型以及CPU.
如果其类型为COLORREF，定义如下：
typedef DWORD COLORREF;
typedef unsigned long DWORD;
则其在32BIT CPU上大小为4，在64BIT CPU上为8

typedef  typedef 的真正意思是给一个已经存在的数据类型（注意：是类型不是变量）取一个别 名，而非定义一个新的数据类型,
也有声明的作用
typedef int a [10];是把a定义为拥有10个整型成员的数组，a b [10]就相当于定义一个整型的二维数组
b [10] [10]，所以要分配400个字节的空间。
＃定义一个INT [10]进行的是字符串替换，A b [10]就是INT [10] b [10]


















