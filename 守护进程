守护进程就是通常讲Daemon进程，是linux后台执行的一种服务进程，特点是独立于控制终端、周期性地执行某种任务或等待处理某些发生事件，不会随终端关闭而停止，直到接受停止信息才会结束，且一般采用以d结尾的名字。

为什么需要守护进程？

 

举例有哪些是守护进程？

linux后台的一些系统服务进程，没有控制终端，不能直接和用户交互，不受用户登录、注销的影响，一直在运行着，他们都是守护进程，如：预读入缓输出机制的实现；ftp服务器（借助vsftpd实现），nfs服务器。

怎么杀死守护进程？

 

守护进程涉及内容：

终端、进程组、会话、创建守护进程。

终端
类UNIX系统中，用户通过终端登录系统后得到一个Shell进程，该终端称为Shell进程的控制终端（Controling Terminal），进程中，控制终端是保存在PCB（进程描述符）中的信息，而fork会复制PCB中的信息，因此由Shell进程启动的其他进程的控制终端也是这个终端。

默认情况下（没有重定向），每个进程的标准输入，标准输出和标准错误输出都指向控制终端，进程从标准输入读也就是读用户的键盘输入，进程往标准输出或标准错误输出写就是输出到显示器上。

信号中涉及，在控制终端输入一些特殊的控制键可以向前台进程发信号，如Ctrl-C表示SIGINT,Ctrl-\表示SIGQUIT（输入输出设备总称）

终端分类
字符终端：ALt+Ctrl+F1、F2、F3、F4、F5、F6

伪终端：pts(pseudo terminal slave)

图像终端：Alt+F7

网络终端：SSH、Telnet

终端启动流程
文件与IO中涉及，每个进程都可以通过一个特殊的设备文件/dev/tty提供一个通用的接口，一个进程要访问它的控制终端既可以通过/dev/tty也可以通关该终端设备所对应的设备文件来访问。ttyname函数可以由文件描述符查出对应的文件名，该文件描述符必须指向一个终端设备而不能是任意文件。

简单来说一个linux系统启动，大致经历如下的步骤：

init-》fork-->exec-->getty-->用户输入账号-->login-->输入密码-->exec-->bash

硬件驱动程序负责读写实际的硬件设备，如从键盘读入字符和把字符输出到显示器。

线路规程像一个过滤器，对于某些特殊字符并不是让它直接通过，而是做特殊处理（拦截特殊字符并做处理），如在键盘上按下Ctrl-z,对应字符并不会被用户程序的read读到，而是被线路规程截获，解释成SIGTSTP信号发给前台进程，通常会使该进程停止。线路规程应该过滤那些字符和做那些特殊处理是可以配置的。

终端设别模块
line discipline:线路规程，用来过滤键盘输入的内容；

ttyname函数

用于由文件描述符查出对应的文件名

char *ttyname(int fd);//成功：终端名；失败：NULL，设置errno
借助ttyname函数，通过实验看下各种不同的终端所对应的设备文件名。

//ttyname.c
#include<unistd.h>
#include<stdio.h>
 
int main(void){
    printf("fd 0:%s\n",ttyname(0));
    printf("fd 1:%s\n",ttyname(1));
    printf("fd 2:%s\n",ttyname(2));
 
    return 0;
}
网络终端

虚拟终端或串口终端是数目是有限的，虚拟终端（字符终端）一般就是六个：/dev/tty1-/dev/tty6，串口终端的数目不超过串口数目。而网络终端或图形终端窗口的数目却是不受限制，这是通过伪终端（Pesudo TTY）实现的。一套伪终端由一个主设备（PTY Master）和一个从设备（PTY Slave）组成。主设备相当于键盘和显示器，它不是一个“真正”的硬件而是一个内核模块，操作它的不是用户而是另外一个进程。从设备类似于/dev/tty1终端设备模块，从设备的底层驱动不是访问硬件而是访问主设备。

网络终端或图形终端窗口的Shell进程以及它启动的其他进程都会认为自己的控制终端是伪终端从设备，如/dev/pts/0、/dev/pts/1等。下面以Telnet为例说明网络登录和使用伪终端的过程。
TCP/IP协议栈：在数据包上添加报头。

如果Telnet客户端和服务器之间的网络延迟较大，我们会观察到按下一个键之后要过几秒才能回显到屏幕上。这过程中涉及：当按一个键Telnet客户端都会立刻把该字符发送给服务器，然后这个字符经过伪终端主设备和从设备之后被Shell进程读取，同时回显到伪终端从设备，回显的字符串再经过伪终端主设备、Telnetd服务器和网络发回给telnet客户端，显示该用户看。
