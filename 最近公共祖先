
以下函数中，和其他函数不属于一类的是_C___。
A、fwrite
B、putc
C、pwrite
D、putchar
E、getline
F、scanf

pwrite是系统调用，其他都是库函数
cntl 文件控制
open 打开文件
creat 创建新文件
close 关闭文件描述字
read 读文件
write 写文件
readv 从文件读入数据到缓冲数组中
writev 将缓冲数组里的数据写入文件
pread 对文件随机读
pwrite 对文件随机写
lseek 移动文件指针
_llseek 在64位地址空间里移动文件指针
dup 复制已打开的文件描述字
dup2 按指定条件复制文件描述字
flock 文件加/解锁
poll I/O多路转换
truncate 截断文件
ftruncate 参见truncate
umask 设置文件权限掩码
fsync 把文件在内存中的部分写回磁盘

下列哪个用法哪个是错误的()
int *a;
extern const int array[256];
const int &ra;
typedef void (*FUN)();

指针本质上是一个存放地址的变量，他是独立的。而引用是别名，
在整个生命周期中对于 将他初始化的变量（也可是指向的表达式）有依附性。相当与访问的接口。需要初始化。

在重载一个运算符为成员函数时，其参数表中没有任何参数，这说明该运算符是 （ ）
A无操作数的运算符
B 二元运算符
C 前缀一元运算符
D 后缀一元运算符
如果友元函数重载一个运算符时，其参数表中没有任何参数则说明该运算符是重载错误 
1.友元函数重载时，参数列表为1，说明是一元，为2是二元； 
2. 成员函数重载时，参数列表为空，是一元，为1是二元； 
3. 定义重载运算符就像定义函数，函数参数表中参数的个数取决于两个因素
1）运算符是一元的（一个参数），还是二元的（两个参数）。
2）运算符被定义为全局函数（对于一元是一个参数，对于二元是二个参数），还是成员函数（对于一元没有参数，对于二元是一个参数-此时该类的对象用作左侧参数（*this））
举例：&操作符和+（加号）操作符
因为++和--有前缀和后缀两种形式，为了区分，要求在后缀形式加一个int参数。  
const Fraction operator ++(int)   中 int不过是个哑元（dummy）,是永远用不上的，它只是用来判断＋＋是prefix  还是  postfix  。
如果有哑元，则是postfix,否则，就是prefix 。 

题目所描述的满二叉树如下： 1 / \ 2 3 / \ / \ 4 5 6 7 上述树中子节点与父节点之间的关系为root = child / 2
所以如果a ！= b，就让其中的较大数除以2， 如此循环直到a == b 即是原来两个数的最近公共祖先 比如： 2
和7的最近公共祖先：7/2 = 3 ---> 3/2 = 1， 2/2 = 1， 得到1为它们的公共祖先
