现在我们常用的C语言是C89标准，C++是C++99标准的。本文在讨论的时候使用的C语言标准是C89，C++标准是C++99.我们来介绍C语言和C++中那些不同的地方。

一、C是面向过程的语言，C++是面向对象的语言。
（Object Oriented Programming）面向对象是一种对现实世界理解和抽象的方法、思想，通过将需求要素转化为对象进行问题处理的一种思想。其核心思想是数据抽象、继承和动态绑定（多态）。
“面向过程”(Procedure Oriented)是一种以过程为中心的编程思想。这些都是以什么正在发生为主要目标进行编程，不同于面向对象的是谁在受影响。

二、C++支持函数重载，而C不支持函数重载。
C语言中产生函数符号的规则是根据名称产生，这也就注定了c语言不存在函数重载的概念。而C++生成函数符号则考虑了函数名、参数个数、参数类型。需要注意的是函数的返回值并不能作为函数重载的依据，也就是说int sum和double sum这两个函数是不能构成重载的！

#include <iostream>

using namespace std;

bool Compare(int a,int b)
{
    return a > b;
}
bool  Compare(double a,double b)
{
    return a > b;
}
int main()
{
    //bool Compare(int a,int b);
    Compare(10,20);
    Compare(10.5,20.5);
    return 0;
}

总结： 编译器调用函数时优先在局部作用域搜索，若搜索成功则全部按照该函数的标准调用。若未搜索到才在全局作用域进行搜索。C语言不存在函数重载，C++根据函数名参数个数参数类型判断重载，属于静多态，必须同一作用域下才叫重载。

三、C是使用malloc/free函数，C++使有new/delete关键字
1.malloc是从堆上开辟空间，而new是从自由存储区开辟。（C++的内存布局：内存区分为5个区，分别是堆、栈、自由存储区、全局/静态存储区、常量存储区）
2.内存不足（开辟失败）时处理方式不同。malloc开辟成功返回void*，需要强转失败返回0，new失败抛出bad_alloc异常。
3.malloc/free是函数，而new/delete是关键字。
4.new的实现可以用malloc，malloc的实现不可以使用new。
5.malloc对开辟的空间大小需要严格指定，而new只需要对象名。
6.free只释放空间，delete先调用析构函数再释放空间（如果需要）；malloc 申请空间，new是先调用构造函数再申请空间（如果需要）。

四、引用和指针
1.指针有自己的一块空间，而引用只是一个别名；
2.使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；
3.指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象
的引用；
4.作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引
用的修改都会改变引用所指向的对象；
5.可以有const指针，但是没有const引用；
6.指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能
被改变；
7.指针可以有多级指针，而引用至于一级。
8.指针和引用使用++运算符的意义不一样；
总结：引用底层就是指针，使用时会直接解引用，可以配合const对一个立即数进行引用。

五、CONST
C语言中被const修饰的变量不是常量，叫做常变量或者只读变量，这个常变量是无法当作数组下标的。然而在C++中const修饰的变量可以当作数组下标使用，成为了真正的常量。这就是C++对const的扩展。

C语言中的const：被修饰后不能做左值，可以不初始化，但是之后没有机会再初始化。不可以当数组的下标，可以通过指针修改。简单来说，它和普通变量的区别只是不能做左值而已。其他地方都是一样的。

C++中的const：真正的常量。定义的时候必须初始化，可以用作数组的下标。const在C++中的编译规则是替换（和宏很像），所以它被看作是真正的常量。也可以通过指针修改。需要注意的是，C++的指针有可能退化成C语言的指针。比如以下情况：
cons t int *p; //修饰的是p所指向的内容不能被改变，p可以；
int const p; //和上面是一样的；
int const p; //修饰的p指针不能改变；

修饰类的成员函数：一般放在成员函数的最后面，修饰的是类的成员
函数中的隐藏参数this指针，代表不可以通过this指针修改类的数据
成员，声明形式例如：
Base::void fun() const;

总结：C中的const叫只读变量，只是无法做左值的变量；C++中的const是真正的常量，但也有可能退化成c语言的常量，默认生成local符号。

六、内联函数inline
在c/c++中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了inline修饰符，表示为内联函数。define作用于程序的预处理阶段，而预处理阶段做的主要工作为下面几个方面：宏替换，去注释以及条件编译； define起作用的地方就在宏替换阶段，只是单纯的将宏替换为代码

栈空间就是指放置程序的局部数据（也就是函数内数据）的内存空间。
在系统下，栈空间是有限的，假如频繁大量的使用就会造成因栈空间不足而导致程序出错的问题，如，函数的死循环递归调用的最终结果就是导致栈内存空间枯竭。
inline的使用时有所限制的，inline只适合函数体内部代码简单多次调用的函数使用，不能包含复杂的结构控制语句例如while、switch，并且不能内联函数本身不能是直接递归函数（即，自己内部还调用自己的函数）。

inline函数仅仅是一个对编译器的建议，所以最后能否真正内联，看编译器的意思
因为内联函数要在调用点展开，所以编译器必须随处可见内联函数的定义，要不然就成了非内联函数的调用了。

总结：C89没有，在调用点直接展开，不生成符号，没有栈帧的开辟回退，仅在Release版本下生效。一般写在头文件中，内联函数避免了频繁调用函数对栈内存重复开辟所带来的消耗。
